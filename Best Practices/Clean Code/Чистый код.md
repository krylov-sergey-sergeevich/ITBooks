[В оглавление](../../README.md)  
  
---  

## Введение  
  
Единственная надежная метрика качества кода: количество «чертей» в минуту.  
  
Профессионализм имеет две составляющие: знания и практический опыт.  

## Предисловие   

```
Честность в мелочах - вовсе не мелочь.  
```

В программирование **80%** и более того называется **«сопровождением»(починкой)**.  

```
«Код есть архитектура»  
```

Практическое применение принципов Lean.  
  
## Глава 1 - Плохой код  

```
Плохой код приводит к краху компании.  
```
 
  
**Закон Леблана:** «потом равносильно никогда».  
  
**Расплата за хаос**  
Грандиозная переработка - это когда разработчики требуют время на рефакторинг и улучшение архитектуры, а бизнес не хочет, не может выделить это время. Так происходит пока разработка не встает намертво и далее идет «реставрация».   
  
Обычно начальники хотят знать правду, даже если по их поведению этого не скажешь. Начальники хотят видеть хороший код, даже если они помешаны на рабочем графике. Они могут страстно защищать график и требования; но это их работа. А ваша работа — так же страстно защищать код.  
  
Программист, который подчиняется воле начальника, не понимающего опасность некачественного кода, проявляет непрофессионализм.   
  
Невозможно написать чистый код, не зная что такое «чистый код».  
  
**Важные пункты:**  
 ⁃ устранение дублирования  
 ⁃ выполнение одной операции  
 ⁃ выразительность  
 ⁃ простые абстракции  
  
Соотношение времени чтения и написания кода превышает 10:1   
  
**Правило бойскаута**   
Оставь место стоянки чище, чем оно было до твоего прихода.  
  
## Глава 2 - Имя переменной  
 ⁃ Что значит?  
 ⁃ Что делает?  
 ⁃ Что хранит?  
  
**Рекомендации**  
 1. Лучше избегать использование в название структур языка (list, map, …)   
 2. Использовать сокращение / аббревиатуры с умом  
 3. Имена должны иметь однозначное соотношение   
 4. Имена должны быть легко-произносимыми  
 5. Имена должны быть предсказуемыми для поиска  
 6. Название интерфейса должно быть без префиксов и суффиксов, лучше в реализации добавить Imp  
 7. Имена классов должны быть существительными или их комбинацией. Имя класса не должно быть глаголом.  
 8. Имена методов должны иметь глагол.  
 9. Избегать шуток следует  
 10. Техническим инструментам/решениям лучше присваивать технические имена  
 11. Использовать язык определенный в доменной области  
  
Следует учесть, что использование префиксов a и the вовсе не является ошибкой, но только при условии, что они создают осмысленные различия. Например, префикс a может присваиваться всем локальным переменным, а префикс the — всем аргументам функций.  
  
## Глава 3 - Функции  
- Должны быть компактными (максимум 20-30 строк)  
- Кол-во отступов в функции должно быть не более 2  
- Функция должна выполнять хорошо только одну операцию  
- switch рекомендуется использовать как можно реже, трансформируя его в абстрактную фабрику для создания полиморфных объектов.  
- Имена должны быть содержательными и их структура должна соответствовать словарю домена.  
- Число аргументов крайне редко должно превышать 3 штуки.   
- Аргументы флаги сигнализируют о том что функция выполняет более одной операции. Следует стараться этого избегать.  
- Побочные эффекты в функции - это зло!  
- Следует разделять функции с командами и запросами. Функция должна что-то делать или отвечать на какой-то вопрос, но не одновременно.  
- Исключения лучше чем коды ошибок.  
- Блоки try/catch лучше скрывать в вспомогательных функция.  
  
**Правило понижения**  
За каждой функцией должны следовать функции следующего уровня абстрак-   
ции. Это позволяет читать код, последовательно спускаясь по уровням абстракции в ходе чтения списка функций.  
  
**Мысль:** идеально написать функцию почти невозможно и не следует пытаться. Сначала пишем как получается, далее пишем тесты, а следом разбиваем функцию на более мелкие блоки. Таким образом получится чистый код.  
  
## Глава 4 - Комментарии  
- Комментарий это признак неудачи выражения идеи в коде  
- Часто комментарий можно заменить созданием функции  
- Юридические комментарии - это нормально  
- Todo комментарии - это терпимо, но не злоупотреблять  
- Комментарии для общедоступного API - это правильно  
- Журнальные комментарии - это зло и пережиток прошлого, сейчас есть git.  
- Позиционные маркеры вида //// можно применять, но крайне редко и по делу.  
- Комментирование кода - это зло!!!  
- HTML в комментариях - это зло  
- В комментариях не должно быть документации (полно-текстовой)  
  
  
## Глава 5 - Форматирование  
- Систему до 50к строк желательно формировать файлами с средним числом 200 строк и максимальным 500 строк.  
- Фрагменты с разной концептуальной идеей нормально разделять пустыми строками  
  
## Глава 6 - Объекты и структуры данных  
  
### Закон Деметры  
Модуль не должен знать внутреннее устройство тех объектов, с которыми он    
работает.  
  
### Объекты передачи данных  
DTO чрезвычайно полезны, особенно при работе с базами данных, разборе сообщений из сокетов и т. д.  
  
## Глава 7 - Обработка ошибок  
- Цена проверяемых исключений — нарушение принципа открытости/закрытости (Мартин)  
  
Если вы инициируете проверяемое исключение из метода своего кода, а catch находится тремя уровнями выше, то это исключение должно быть объявлено в сигнатурах всех методов между вашим методом и catch. Следовательно, изменение на низком уровне программного продукта приводит к изменениям сигнатур на многих более высоких уровнях.   
Измененные модули приходится строить и развертывать заново, притом что в программе не изменилось ничего, что было бы существенно для них.   
  
Таким образом используем непроверяемые исключения.  
  
- В исключение должен быть контекст   
  
ОСОБЫЙ СЛУЧАЙ `Fowler`  
  
- Не возвращайте null  
- Не передавайте null в методах  

## Глава 8 - Границы  
**Методы сохранения чистоты границ ПО**  
 ⁃ Учебные тесты для стороннего кода  
 ⁃ Адаптер полезная штука  
   
## Глава 9 - Модульные тесты  
**Паттерны:**  
- Для написания теста: given-when-then  
- Для избежания дублирования: GOF шаблонный метод  
  
 ⁃ Нужен интеграционный тест   
 ⁃ Плохие тесты равносильны отсутствию тестов  
 ⁃ Слишком простые трудно изменять, тесты должны быть «умными»  
 ⁃ Тестовый код >= обычному коду по важности  
 ⁃ Тест в идеале должен стремиться быть как DSL  
 ⁃ ± Одна проверка на тест это неоднозначно  
 ⁃ Тесты должны соблюдать FIRST  
  
### FIRST
 ⁃ Быстрые  
 ⁃ Независимость  
 ⁃ Повторяемость  
 ⁃ Очевидность  
 ⁃ Своевременность  
   
## Глава 10 - Классы  
 ⁃ Классы должны быть компактными  
 ⁃ Небольшое число ответственности RDD  
 ⁃ Нужно следить за связностью  
 ⁃ Нужно изолировать элементы системы  
 ⁃ Связано с Dependency Inversion Principle (по сути DIP говорит, что классы должны зависеть от абстракций, а не от конкретных реализаций)  
   
## Глава 11 - Системы  
Сложность убивает. Она вытягивает жизненные силы из разработчиков, затрудняя планирование, построение и тестирование продуктов.   
  
 ⁃ Нужно отделять конструирование от использования  
 ⁃ Используем Dependency Injection (IOC)  
 ⁃ Построить правильную систему с первого раза - нереально. Поэтому решаем текущие потребности, а далее расширяем.  
 ⁃ Big Design Up Front - вредно, тк снижает возможность адаптации к изменениям из-за нашего психологического нежелания расставаться с результатами уже затраченных усилий  
 ⁃ Оптимальная архитектура системы состоит из модульных областей ответственности, каждая из которых реализуется на базе POJO-объектов. Области интегрируются между собой при помощи аспектов или аналогичных средств, минимальным образом вмешивающихся в их работу. Такая архитектура может строиться на базе методологии разработки через тестирование, как и программный код.  
 ⁃ Стандарты нужно применять, но при этом не все и не бездумно.  
 ⁃ DSL позволяет писать код понятнее для жителей системы  
   
## Глава 12 - Формирование архитектуры  
SRP - принцип единой ответственности   
DIP - принцип обращения зависимостей  
  
### Простая архитектура   
 ⁃ обеспечивает прохождение всех тестов  
 ⁃ не содержит дублирующего кода  
 ⁃ выражает намерения программиста   
 ⁃ использует минимальное кол-во классов и методов  
  
Основные затраты программного проекта связаны с его долгосрочным сопровождением. Чтобы свести к минимуму риск появления дефектов в ходе внесения изменений, очень важно понимать, как работает система.  
  
Нужно:  
 ⁃ хорошие имена переменных  
 ⁃ отличные имена классов  
  
### Полезные паттерны
 ⁃ шаблонный метод  
 ⁃ команда  
 ⁃ посетитель  
   
## Глава 13 - Многопоточность  
  
### Мифы
- Многопоточность всегда повышает быстродействие  
- Многопоточный код не меняет архитектуру программы  
  
### Правда
- Многопоточность стоит дороже и сложна  
- Ошибки крайне трудно отловить и повторить  
- Требуется знание теории  
  
### Защита от ошибок многопоточности  
- Отделяйте код относящийся к реализации многопоточности от остального кода. Чтобы стремиться к SRP.  
- Жестко ограничивать доступ к общим данным  
- Копия объекта даст иногда альтернативное решение  
- Использовать потоково-безопасные коллекции следует  
- Следует остерегаться зависимостей между синхронизированными методами  
- Синхронизированные функции должны быть небольшими и простыми  
- Писать многопоточный код так, чтобы кол-во потоков было настраиваемым  
  
**Реализация ConcurrentHashMap почти всегда работает лучше HashMap.**  
  
### Модели
- Производители-потребители  
- Читатели-писатели  
- Обедающие философы  
  
## Глава 14 - Последовательное очищение  
  
 ⁃ TDD / Тесты - без этого нельзя  
  
## Глава 15 - Внутреннее строение JUnit  
  
 ⁃ Оставляй код лучше чем он был до тебя  
  
## Глава 16 - Переработка SerialDate  
  
- Надо спокойно относиться к ревью.
  
> *Заметки: Много обсуждения кода*  
  
## Глава 17 - Запахи и эвристические правила  
  
**Плохая практика:**  
- Хранить в коде ссылки на автора, даты, устаревшие комментарии  
- Хранить закомментированный код  
- Аргументы флаги это не лучшая практика  
- Не полагайтесь на интуицию  
- Не отключайте средства безопасности  
- Дублирование это ЗЛО (DRY не зря придумали)  
- Волшебные непонятные числа  
  
**Хорошая практика:**  
- Структура важней конвенций  
  
**Сомнительные моменты:**  
- switch case на полиморфизм  
- используйте обобщенные директивы импорта `*`  
- константы в интерфейсе это плохая практика