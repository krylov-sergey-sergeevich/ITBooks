[В оглавление](../../README.md)  

**Автор: Роберт Мартин**

**Оглавление:**

1. [Введение](#%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5)
	1. [Что такое дизайн и архитектура?](#%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B4%D0%B8%D0%B7%D0%B0%D0%B9%D0%BD-%D0%B8-%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0)
			1. [Пример](#%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80)
			1. [Самонадеянность](#%D0%A1%D0%B0%D0%BC%D0%BE%D0%BD%D0%B0%D0%B4%D0%B5%D1%8F%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D1%8C)
	1. [История о двух ценностях](#%D0%98%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F-%D0%BE-%D0%B4%D0%B2%D1%83%D1%85-%D1%86%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D1%8F%D1%85)
			1. [Матрица Эйзенхауэра](#%D0%9C%D0%B0%D1%82%D1%80%D0%B8%D1%86%D0%B0-%D0%AD%D0%B9%D0%B7%D0%B5%D0%BD%D1%85%D0%B0%D1%83%D1%8D%D1%80%D0%B0)
			1. [Битва за архитектуру](#%D0%91%D0%B8%D1%82%D0%B2%D0%B0-%D0%B7%D0%B0-%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D1%83)
1. [Начальные основы: парадигмы программирования](#%D0%9D%D0%B0%D1%87%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-%D0%BF%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D1%8B-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
	1. [Обзор парадигм](#%D0%9E%D0%B1%D0%B7%D0%BE%D1%80-%D0%BF%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC)
	1. [Структурное программирование](#%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
			1. [Не все можно доказать](#%D0%9D%D0%B5-%D0%B2%D1%81%D0%B5-%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D0%B4%D0%BE%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D1%8C)
			1. [Тестирование](#%D0%A2%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
			1. [Заключение](#%D0%97%D0%B0%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5)
	1. [ООП](#%D0%9E%D0%9E%D0%9F)
		1. [Инкапсуляция](#%D0%98%D0%BD%D0%BA%D0%B0%D0%BF%D1%81%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D1%8F)
		1. [Наследование](#%D0%9D%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
		1. [Полиморфизм](#%D0%9F%D0%BE%D0%BB%D0%B8%D0%BC%D0%BE%D1%80%D1%84%D0%B8%D0%B7%D0%BC)
		1. [Заключение](#%D0%97%D0%B0%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5)
	1. [Функциональное программирование](#%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
		1. [Неизменяемость и архитектура](#%D0%9D%D0%B5%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D1%8F%D0%B5%D0%BC%D0%BE%D1%81%D1%82%D1%8C-%D0%B8-%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0)
			1. [Компромисс 1: Ограничение изменяемости](#%D0%9A%D0%BE%D0%BC%D0%BF%D1%80%D0%BE%D0%BC%D0%B8%D1%81%D1%81-1-%D0%9E%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D1%8F%D0%B5%D0%BC%D0%BE%D1%81%D1%82%D0%B8)
			1. [Компромисс 2: Регистрация событий](#%D0%9A%D0%BE%D0%BC%D0%BF%D1%80%D0%BE%D0%BC%D0%B8%D1%81%D1%81-2-%D0%A0%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9)
1. [Принципы дизайна](#%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-%D0%B4%D0%B8%D0%B7%D0%B0%D0%B9%D0%BD%D0%B0)
	1. [SOLID](#solid)
1. [Принципы организации компонентов](#%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-%D0%BE%D1%80%D0%B3%D0%B0%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2)
	1. [Связность компонентов](#%D0%A1%D0%B2%D1%8F%D0%B7%D0%BD%D0%BE%D1%81%D1%82%D1%8C-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2)
		1. [Диаграмма противоречий принципов связности](#%D0%94%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0-%D0%BF%D1%80%D0%BE%D1%82%D0%B8%D0%B2%D0%BE%D1%80%D0%B5%D1%87%D0%B8%D0%B9-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D0%BE%D0%B2-%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D0%BE%D1%81%D1%82%D0%B8)
	1. [Сочетаемость компонентов](#%D0%A1%D0%BE%D1%87%D0%B5%D1%82%D0%B0%D0%B5%D0%BC%D0%BE%D1%81%D1%82%D1%8C-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2)
		1. [Принцип ацикличности зависимостей](#%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF-%D0%B0%D1%86%D0%B8%D0%BA%D0%BB%D0%B8%D1%87%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B5%D0%B9)
			1. [Еженедельные сборки](#%D0%95%D0%B6%D0%B5%D0%BD%D0%B5%D0%B4%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%81%D0%B1%D0%BE%D1%80%D0%BA%D0%B8)
			1. [Устранение циклических зависимостей](#%D0%A3%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D1%86%D0%B8%D0%BA%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D1%85-%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B5%D0%B9)
		1. [Проектирование сверху вниз](#%D0%9F%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B2%D0%B5%D1%80%D1%85%D1%83-%D0%B2%D0%BD%D0%B8%D0%B7)
		1. [Принцип устойчивых зависимостей](#%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF-%D1%83%D1%81%D1%82%D0%BE%D0%B9%D1%87%D0%B8%D0%B2%D1%8B%D1%85-%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B5%D0%B9)
			1. [Метрика устойчивости](#%D0%9C%D0%B5%D1%82%D1%80%D0%B8%D0%BA%D0%B0-%D1%83%D1%81%D1%82%D0%BE%D0%B9%D1%87%D0%B8%D0%B2%D0%BE%D1%81%D1%82%D0%B8)
		1. [Принцип устойчивости абстракций](#%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF-%D1%83%D1%81%D1%82%D0%BE%D0%B9%D1%87%D0%B8%D0%B2%D0%BE%D1%81%D1%82%D0%B8-%D0%B0%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%86%D0%B8%D0%B9)
			1. [Мера абстрактности](#%D0%9C%D0%B5%D1%80%D0%B0-%D0%B0%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%BE%D1%81%D1%82%D0%B8)
1. [Архитектура](#%D0%90%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0)
	1. [Независимость](#%D0%9D%D0%B5%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C)
		1. [Дублирование](#%D0%94%D1%83%D0%B1%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
	1. [Границы: проведение разделяющих линий](#%D0%93%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D1%8B-%D0%BF%D1%80%D0%BE%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D1%8E%D1%89%D0%B8%D1%85-%D0%BB%D0%B8%D0%BD%D0%B8%D0%B9)
	1. [Бизнес-правила](#%D0%91%D0%B8%D0%B7%D0%BD%D0%B5%D1%81-%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0)
	1. [Цель архитектуры](#%D0%A6%D0%B5%D0%BB%D1%8C-%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D1%8B)
	1. [Чистая архитектура](#%D0%A7%D0%B8%D1%81%D1%82%D0%B0%D1%8F-%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0)
	1. [Неполные границы](#%D0%9D%D0%B5%D0%BF%D0%BE%D0%BB%D0%BD%D1%8B%D0%B5-%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D1%8B)
	1. [Границы тестов](#%D0%93%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D1%8B-%D1%82%D0%B5%D1%81%D1%82%D0%BE%D0%B2)
	1. [Чистая встраиваемая архитектура](#%D0%A7%D0%B8%D1%81%D1%82%D0%B0%D1%8F-%D0%B2%D1%81%D1%82%D1%80%D0%B0%D0%B8%D0%B2%D0%B0%D0%B5%D0%BC%D0%B0%D1%8F-%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0)
1. [Детали](#%D0%94%D0%B5%D1%82%D0%B0%D0%BB%D0%B8)

---  


# Введение

## Что такое дизайн и архитектура?

⭐ㅤМежду словом дизайн и архитектура нет никакой разницы.

- **Архитектура** — используется в общих рассуждениях.
- **Дизайн** — используется при обсуждение организации на более низком уровне.

Но такое разделение бессмысленно, когда речь идет о том, что делает настоящий архитектор. Низкоуровневые детали и высокоуровневая структура являются частями одного целого. Они образуют сплошное полотно, определяющее форму системы. Одно без другого невозможно; нет никакой четкой линии, которая разделяла бы их. Есть просто совокупность решений разного уровня детализации.


ℹ️ㅤ**Цель архитектуры программного обеспечения** — уменьшить человеческие трудозатраты на создание и сопровождение системы.

**Мера измерения качества:**
- Кол-во трудозатрат для удовлетворения потребностей клиента.

#### Пример
![](__resources__/Pasted%20image%2020231111124335.png)

![](__resources__/Pasted%20image%2020231111124410.png)


#### Самонадеянность


> Примерно 2600 лет тому назад Эзоп сочинил басню о Зайце и Черепахе.
> Мораль той басни можно выразить по-разному:
> - «медленный и постоянный побеждает в гонке»;
> - «в гонке не всегда побеждает быстрейший, а в битве — сильнейший»;
> - «чем больше спешишь, тем меньше успеваешь».
> 
> Притча подчеркивает глупость самонадеянности. Заяц был настолько уверен в своей скорости, что не отнесся всерьез к состязанию, решил вздремнуть и проспал, когда Черепаха пересекла финишную черту.

⚡ㅤ**ЛОЖЬ**
*«Мы сможем навести порядок потом, нам бы только выйти на рынок!»*

⚡ㅤ**Простая истина**
1. *Поспешай не торопясь.*

2. *Самонадеянность, управляющая перепроектированием, приведет к тому же беспорядку, что и прежде.*

## История о двух ценностях

**Любое ПО имеет две ценности:**
- поведение
- архитектура

ℹ️ㅤ**Поведение** - чтобы код решал поставленную задачу.
- Срочное, но не всегда важное

ℹ️ㅤ**Архитектура** - код должен легко расширяться и поддерживаться.
- Важное, но не всегда срочное

#### Матрица Эйзенхауэра

**Эйзенхауэр говорил так:**
*У меня есть два вида дел, срочные и важные. Срочные дела, как правило, не самые важные, а важные — не самые срочные.*

![](__resources__/Pasted%20image%2020231112110015.png)

#### Битва за архитектуру

ㅤㅤЕсли поместить архитектуру на последнее место, разработка системы будет обходиться все дороже, и в конце концов внесение изменений в такую систему или в отдельные ее части станет практически невозможным. Если это случилось, значит, команда разработчиков сражалась недостаточно стойко за то, что они считали необходимым.


# Начальные основы: парадигмы программирования

## Обзор парадигм

1. **Структурное программирование** накладывает ограничение на прямую пере-
дачу управления.
2. **Объектно-ориентированное программирование** накладывает ограничение на
косвенную передачу управления.
3. **Функциональное программирование** накладывает ограничение на присваи-
вание.

> Парадигмы говорят нам не столько что делать, сколько чего нельзя делать.

> Доказательством отсутствия новых парадигм может служить
тот факт, что все три известные парадигмы были открыты в течение десяти
лет, между 1958 и 1968 годами. За многие последующие десятилетия не по-
явилось ни одной новой парадигмы.

## Структурное программирование

> Иерархическая структура блоков.

📜ㅤПрограмма любой сложности содержит слишком много деталей, чтобы человеческий
мозг смог справиться с ней без посторонней помощи.

📜ㅤGo To Statement Considered Harmful («О вреде оператора Go To») - 10-летняя война Дейкстры против **goto**.

#### Не все можно доказать

![](__resources__/Pasted%20image%2020231112194501.png)

#### Тестирование

**Дейкстра сказал:** 
🌀ㅤ«Тестирование показывает присутствие ошибок, а не их отсутствие»

#### Заключение

ㅤВозможность создавать программные единицы, неправильность которых можно доказать, является главной ценностью структурного программирования.

ㅤФункциональная декомпозиция считается одним из лучших приемов на архитектурном уровне.

## ООП

### Инкапсуляция

📜ㅤЯзыки Java и C# полностью отменили деление на заголовок/реализацию, ослабив инкапсуляцию еще больше. В этих языках невозможно разделить объявление и определение класса.
📜ㅤВ действительности многие языки ОО практически не имеют принудительной инкапсуляции (Java, C# в отличие от С).

### Наследование

📜ㅤЯзыки ОО не улучшили инкапсуляцию, зато они дали нам наследование.

### Полиморфизм

📜ㅤЯзыки ОО избавляют от необходимости помнить об этих соглашениях и, соответственно, устраняют опасности, связанные с этим. Поддержка полиморфизма на уровне языка делает его использование тривиально простым. Это обстоятельство открывает новые возможности, о которых программисты на C могли только мечтать. Отсюда можно заключить, что ОО накладывает ограничение на косвенную передачу управления.

📜ㅤФакт поддержки языками ОО надежного и удобного механизма полиморфизма означает, что любую зависимость исходного кода, где бы она ни находилась, можно инвертировать.

### Заключение

Что такое ОО? Существует много взглядов и ответов на этот вопрос. Однако для программного архитектора ответ очевиден: ОО дает, посредством поддержки полиморфизма, абсолютный контроль над всеми зависимостями в исходном коде. Это позволяет архитектору создать архитектуру со сменными модулями (плагинами), в которой модули верхнего уровня не зависят от модулей нижнего уровня. Низкоуровневые детали не выходят за рамки модулей плагинов, которые можно развертывать и разрабатывать независимо от модулей верхнего уровня.

## Функциональное программирование

🎓ㅤЭта парадигма в значительной мере основана на λ-исчислении, изобретенном Алонзо Чёрчем в 1930-х годах.

🎓ㅤПеременные в функциональных языках не изменяются.

### Неизменяемость и архитектура

**Почему архитектора должна волновать изменчивость переменных?** **Ответ на этот вопрос до нелепого прост:** все состояния гонки (race condition), взаимоблокировки (deadlocks) и проблемы параллельного обновления обусловлены изменяемостью переменных.

#### Компромисс 1: Ограничение изменяемости

ㅤОдин из самых общих компромиссов, на которые приходится идти ради неизменяемости, — деление приложения или служб внутри приложения на изменяемые и неизменяемые компоненты. Неизменяемые компоненты решают свои задачи исключительно функциональным способом, без использования изменяемых переменных. Они взаимодействуют с другими компонентами, не являющимися чисто функциональными и допускающими изменение состояний переменных.

#### Компромисс 2: Регистрация событий
ㅤЭта идея положена в основу технологии регистрации событий (event sourcing)1. Регистрация событий (event sourcing) — это стратегия, согласно которой сохраняются транзакции, а не состояние. Когда требуется получить состояние, мы просто применяем все транзакции с самого начала.


# Принципы дизайна

ℹ️ㅤЦель принципов SOLID — создать программные структуры среднего уровня, которые:
- терпимы к изменениям;
- просты и понятны;
- образуют основу для компонентов, которые могут использоваться во многих программных системах.

## SOLID
ㅤ
- **SRP: Single Responsibility Principle** — принцип единственной ответственности.
	- Каждый программный модуль имеет одну и только одну причину для изменения.
	- Модуль должен отвечать за одного и только за одного актора.
	- На уровне компонентов принцип превращается в принцип согласованного изменения (**Common Closure Principle; CCP**).
	- На архитектурном уровне — в принцип оси изменения (**Axis of Change**), отвечающий за создание архитектурных границ.
- **OCP: Open-Closed Principle** — принцип открытости/закрытости.
	- Простая для изменения система должна предусматривать простую возможность изменения ее поведения добавлением нового, но не изменением существующего кода.
	- Принцип открытости/закрытости — одна из движущих сил в архитектуре систем. Его цель — сделать систему легко расширяемой и обезопасить ее от влияния изменений. Эта цель достигается делением системы на компоненты и упорядочением их зависимостей в иерархию, защищающую компоненты уровнем выше от изменений в компонентах уровнем ниже.
- **LSP: Liskov Substitution Principle** — принцип подстановки Барбары Лисков.
	- Принцип утверждает, что для создания программных систем из взаимозаменяемых частей эти части должны соответствовать контракту, который позволяет заменять эти части друг другом.
	- На заре объектно-ориентированной революции принцип LSP рассматривался как руководство по использованию наследования, как было показано в предыдущих разделах. Но со временем LSP был преобразован в более широкий принцип проектирования программного обеспечения, который распространяется также на интерфейсы и реализации.
	- Простое нарушение совместимости может вызвать загрязнение архитектуры системы значительным количеством дополни- тельных механизмов.
- **ISP: Interface Segregation Principle** — принцип разделения интерфейсов.
	- Этот принцип призывает разработчиков программного обеспечения избегать зависимости от всего, что не используется.
	- Зависимости, несущие лишний груз ненужных и неиспользуемых особенностей, могут стать причиной неожиданных проблем.
- **DIP: Dependency Inversion Principle** — принцип инверсии зависимости.
	- Код, реализующий высокоуровневую политику, не должен зависеть от кода, реализующего низкоуровневые детали.

> Паттерн Interactor

# Принципы организации компонентов

ㅤПринципы SOLID определяют, как выкладывать кирпичами стены, обра- зующие комнаты, а принципы организации компонентов — как размещать комнаты в зданиях. Большие программные системы, подобно большим зданиям, строятся из меньших компонентов.

## Связность компонентов

- **REP: Reuse/Release Equivalence Principle** — принцип эквивалентности повторного использования и выпусков;
- **CCP: Common Closure Principle** — принцип согласованного изменения;
	- В один компонент должны включаться классы, изменяющиеся по одним причинам и в одно время. В разные компоненты должны включаться классы, изменяющиеся в разное время и по разным причинам.
- **CRP: Common Reuse Principle** — принцип совместного повторного использования.
	- Не вынуждайте пользователей компонента зависеть от того, чего им не требуется.

### Диаграмма противоречий принципов связности

![](__resources__/Pasted%20image%2020231112215210.png)

## Сочетаемость компонентов

### Принцип ацикличности зависимостей

⚡ㅤЦиклы в графе зависимостей компонентов недопустимы.

#### Еженедельные сборки

ㅤЕженедельные сборки часто используются в проектах среднего размера. Это решение действует так: все разработчики работают независимо первые четыре дня в неделе. Они изменяют собственные копии кода и не заботят- ся об интеграции результатов своего труда в коллективную основу. Затем, в пятницу, они объединяют свои изменения и пытаются собрать систему. Этот подход имеет замечательное преимущество, позволяя разработчикам работать в изоляции четыре дня из пяти. Недостаток, конечно же, — большие трудозатраты на интеграцию в пятницу.

#### Устранение циклических зависимостей

📜ㅤОбратите внимание, что структура имеет вид ориентированного (направленного) графа. Компоненты играют роль узлов, а зависимости между ними — ориентированных ребер.

![](__resources__/Pasted%20image%2020231112220701.png)

### Проектирование сверху вниз

⚡ㅤСтруктура компонентов не может проектироваться сверху вниз.

ㅤПопытка спроектировать структуру зависимостей компонентов раньше любых классов, скорее всего, потерпит неудачу. На этом этапе мы почти ни- чего не знаем о согласовании изменений, не представляем, какие элементы можно использовать многократно и почти наверняка создадим компоненты, образующие циклические зависимости. Поэтому структура зависимостей компонентов должна расти и развиваться вместе с логическим дизайном системы.


### Принцип устойчивых зависимостей

ㅤЕсли все компоненты в системе будут иметь максимальную устойчивость, такую систему невозможно будет изменить. Это нежелательная ситуация. В действительности структура компонентов должна проектироваться так, чтобы в ней имелись и устойчивые, и неустойчивые компоненты.

![](__resources__/Pasted%20image%2020231112221351.png)

#### Метрика устойчивости

![](__resources__/Pasted%20image%2020231112221419.png)

### Принцип устойчивости абстракций

🌀ㅤ**Устойчивость компонента пропорциональна его абстрактности.**

ℹ️ㅤ**Stable Abstractions Principle; SAP** - устанавливает связь между устойчивостью и абстрактностью.

#### Мера абстрактности

- Nc: число классов в компоненте.
- Na: число абстрактных классов и интерфейсов в компоненте.

Мерой абстрактности компонента служит метрика A = Na ÷ Nc.

Значение метрики A изменяется в диапазоне от 0 до 1. 0 означает полное отсутствие абстрактных классов в компоненте, а 1 означает, что компонент не содержит ничего, кроме абстрактных классов.

![](__resources__/Pasted%20image%2020231112222253.png)

# Архитектура

![](__resources__/Pasted%20image%2020231112222744.png)

ㅤ**Предназначение архитектуры** — поддержка жизненного цикла системы. Хорошая архитектура делает систему легкой в освоении, простой в разработке, сопровождении и развертывании. Конечная ее цель — минимизировать затраты на протяжении срока службы системы и максимизировать продуктивность программиста.

## Независимость

Хорошая архитектура должна обеспечивать:
- Разнообразие вариантов использования и эффективную работу системы.
	- *Режим разделения — одна из таких возможностей.*
- Простоту сопровождения системы.
- Простоту разработки системы.
- Простоту развертывания системы.

Части, которые должны выполняться с максимальной пропускной способностью, можно запустить на нескольких серверах. Такие элементы называют:
- служба или сервис

### Дублирование

**Дублирование бывает двух типов:**
- Истинное 
- Ложное - когда сходство, это случайность. По этой причине желательно избежать их объединения. Иначе потом разделить их будет очень сложно.

## Границы: проведение разделяющих линий

ℹ️ㅤ**Разработка архитектуры программного обеспечения** — это искусство проведения разделяющих линий, которые я называю границами.

⚡ㅤ**Целью архитектора** - является минимизация трудозатрат на
создание и сопровождение системы.

> «Контроль» — это второе имя того парня. Это тоже плохо.


## Бизнес-правила

📜ㅤБизнес-правила должны оставаться в неприкосновенности, незапятнанными низкоуровневыми аспектами, такими как пользовательский интерфейс или база данных. В идеале код, представляющий бизнес-правила, должен быть сердцем системы, а другие задачи — просто подключаться к ним. Реализация бизнес-правил должна быть самым независимым кодом в системе, готовым к многократному использованию.


## Цель архитектуры

ㅤ**Хорошие архитектуры опираются на варианты использования** и помогают архитекторам описывать структуры, поддерживающие эти варианты использования, не связывая себя фреймворками, инструментами и окружениями.

## Чистая архитектура

![](__resources__/Pasted%20image%2020231112231022.png)

ㅤНесмотря на различия в деталях, **все эти архитектуры очень похожи.** Они все преследуют одну цель — **разделение задач**. Они все достигают этой цели путем деления программного обеспечения на уровни.

ㅤКаждая из этих архитектур способствует созданию систем, обладающих следующими характеристиками:

![](__resources__/Pasted%20image%2020231112231204.png)

**Попытка объединить все эти архитектуры в одну практически осуществимую идею:**
![](__resources__/Pasted%20image%2020231112231307.png)

⚡ㅤ**Фактически нет никакого правила, утверждающего, что кругов должно быть именно четыре.**

![](__resources__/Pasted%20image%2020231112231637.png)

## Неполные границы

ㅤПолноценные архитектурные границы обходятся дорого. Они требуют определения двусторонних пограничных интерфейсов, структур для входных и выходных данных и управления зависимостями для выделения двух сторон в компоненты, компилируемые и развертываемые независимо. Это требует значительных усилий для создания и сопровождения. Во многих ситуациях хороший архитектор мог бы посчитать затраты на создание такой границы слишком высокими, но хотел бы сохранить место для такой границы на будущее. Подобное упреждающее проектирование часто расценивается многими по- следователями гибкой разработки как нарушение принципа YAGNI: «You Aren’t Going to Need It» («Вам это не понадобится»). Однако некоторые архитекторы смотрят на эту проблему и думают: «А мне может это понадобиться». В этом случае они могут реализовать неполную границу.

> Паттерн (шаблон) Facade является простым способом к организации границы, тк отсутствует даже инверсия зависимостей.

ㅤВот так-то, Архитектор Программного Обеспечения, вы должны предвидеть будущее. Вы должны предугадывать с пониманием дела. Вы должны взвесить все за и против, определить, где пролегают архитектурные границы и какие из них должны быть реализованы полностью, какие частично, а ка- кие можно вообще игнорировать. Но это не единовременное решение. Невозможно раз и навсегда решить на ранних этапах проектирования, какие границы реализовать, а какие игнорировать. Вы должны наблюдать за развитием системы, отмечать места, где может потребоваться провести новую границу, и затем внимательно следить за появлением первых трений, возникающих из-за отсутствия границ. В этот момент нужно взвесить затраты на реализацию границ и цену их игнорирования и принять решение. Ваша цель — создать границу прямо в точке перегиба, когда реализовать ее окажется дешевле, чем продолжать игнорировать. Для этого вы должны наблюдать очень внимательно.

## Границы тестов
ㅤ
ㅤТесты, недостаточно хорошо интегрированные в дизайн системы, обычно оказываются **хрупкими** и делают систему жесткой и неудобной для изменения.

1. не зависеть ни от чего, что может часто меняться

## Чистая встраиваемая архитектура

> Несмотря на то что программное обеспечение не изнашивается, встроенные микропрограммы и оборудование устаревают, что требует модификации программного обеспечения.

![](__resources__/Pasted%20image%2020231112234258.png)

# Детали

- Данные — значимы, а база данных — это деталь.
- Веб — это деталь.
- Фреймворк — это деталь.

![](__resources__/Pasted%20image%2020231112235357.png)

